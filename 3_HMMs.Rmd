---
title: "Introduction to Hidden Markov Models"
author: "Jared Stabach, Smithsonian's National Zoo & Conservation Biology Institute"
date: '`r format(Sys.time(), "%d %B %Y")`'
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: 
      collapsed: true
      smooth_scroll: true
    number_sections: false
    #theme: united
    #highlight: tango
pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<a href="https://github.com/Smithsonian/Wildebeest_HMM.git" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

# Introduction
  >Many thanks to Dr. Joe Kolowski for assistance in developing this material
  
In this exercise, we will fit Hidden Markov Models (HMMs) with the [moveHMM](https://cran.r-project.org/web/packages/moveHMM/index.html) package to assess changes in wildebeest behavior.  We will continue to use the dataset from previous exercises that has been cleaned and subset to the Athi-Kaputiei Plains study area in southern Kenya.  Remember that the data have been re-sampled to a 3-hour fix interval.  We'll investigate the role of temperature and time of day on the movement behaviors of wildebeest, but many other environmental variables (e.g., Anthropogenic Disturbance) could be added to further our understanding on potential impacts to animals.

Code is based on exercises developed by Joe Kolowski at the Smithsonian-Mason School of Conservation, with sections modified from the [moveHMM](https://cran.r-project.org/web/packages/moveHMM/index.html) guide. 

In this exercise, we will:

  * Learn the analysis workflow for fitting Hidden Markov Models with [moveHMM](https://cran.r-project.org/web/packages/moveHMM/index.html)
  * Practice investigation of impact of continuous covariates on state transition probabilities 
  * Learn how to interpret output from HMMs
  * Practice methods for visualizing HMM output both spatially and graphically
  * Use model output to subset tracking datasets
  
## Load Libraries
Load the required libraries and remove everything held in [R's](https://cran.r-project.org/) memory.

```{r Setup, message=FALSE, warning=FALSE, echo=TRUE}
# Remove items from memory/clean your workspace
rm(list=ls())

# You may need to install these packages first
#install.packages('moveHMM', 'lubridate', 'tidyverse')

# Load libraries
library(moveHMM)
library(lubridate)
library(tidyverse)
```

## Data Import & Formatting
Load the cleaned wildebeest dataset from the previous exercise.   In terms of data preparation, a few processing/formatting steps are required:

  * It is assumed that location error is relatively small. If you are working with a high error data set, you should likely process it before using this package. For example, you may try a state space approach, such as [crawl](https://cran.r-project.org/web/packages/crawl/index.html) or [aniMotum](https://ianjonsen.github.io/aniMotum/articles/Overview.html). 
  * Note that [moveHMM](https://cran.r-project.org/web/packages/moveHMM/index.html) does not use date/time information.  We have already verified that our dataset is regular, but you also need to verify that the data is organized chronologically.
  * Variables included in analyses must be numeric.  For example, seasons should be changed to 1, 2, 3, and 4 to be incorporated in analyses. 
  * The animal id column must be named "ID".
  * It seems very helpful to convert the coordinates (currently in meters) to km by dividing by 1000.  All [moveHMM](https://cran.r-project.org/web/packages/moveHMM/index.html) vignettes do this unit conversion.

```{r Load, message=FALSE, warning=FALSE, echo=TRUE}
# Read the dataset into R, selecting the necessary columns (x, y, date, id) for analyses.
# We will also grab the temperature column and the sex of each animal and convert the x/y values to km (e.g., x/1000).
# Lastly, we'll create an hour field from the timestamp and make sex a numeric variable, even though we won't use this field as a covariate in our models. 
WB.data <- read_rds("Data/wildebeest_3hr_adehabitat.rds") %>%
  arrange(id, date) %>%
  select(x,
         y,
         t = date,
         ID = id,
         temp,
         sex) %>% 
  mutate(hour = hour(t),
         x = x/1000,
         y = y/1000,
         sex = as.numeric(sex))
```

# Create Move Object
Now that we have imported the data, we will use the function `prepData` to prepare the data for analyses.  If our data were raw lat/long values, we could still import the data, but we would need to set the type = "LL" (default). See `help(prepData)` for additional information.  

**Note** This package only works with longitude/latitude and UTM projected data.

```{r Create, message=FALSE, warning=FALSE, echo=TRUE}
# Create Object
WB.move <- WB.data  %>% 
  prepData(type = "UTM",
           coordNames = c("x","y"))

# You will likely receive a warning message that some of the covariate data is missing.
# This is ok.  These are records where the x/y location is missing, so the covariate data is na.

# What's the class of the object?
class(WB.move)
```

### Object Summary
The [moveHMM](https://cran.r-project.org/web/packages/moveHMM/index.html) package includes a number of functions to help summarize the content of the move object.  We'll see that we have movement data for all 12 wildebeest (a good check!), with two covariates (temperature and hour of day) to use in analyses.  We also see from above that the format is a data.frame, making it relatively easy to modify our object if we need to.  Also notice that the function `prepData` created two additional columns in our dataset, "step (steplength)" and "angle (turning angle)".  These are the two fields that will be used in all future modeling steps with this package.  The plot function will show the movement trajectory and include plots of the steplengths and turning angles. 

```{r Move Summary, message=FALSE, warning=FALSE, echo=TRUE}
# Summarize the object
summary(WB.move)

# What are the column headings included in this move object?
names(WB.move)

# We can plot all animals together.  Please try!
# plot(WB.move,
#      compact = TRUE, # Make sure you specify compact = TRUE.  If you don't specify, each plot will be drawn separately, which can be tedious
#      ask = FALSE)

# Or, each animal separately
# unique(WB.move$ID) # We can always query the dataframe for the names of each animal.
plot(WB.move[WB.move$ID == "Kikaya",],
     ask = FALSE)

# We can also investigate the steplength and turning separately, using standard R commands
# hist(WB.move$step)
# summary(WB.move$step)
# quantile(WB.move$step,
#          probs = 0.90,
#          na.rm = TRUE)
# hist(WB.move$angle)
```

# Fitting a Hidden Markov Model
To begin modeling, we need to set starting values for all relevant estimable parameters.  As a starting point, we will fit a 2-state NULL model and therefore need to provide initial values for two vectors, stepPar0 (for the step distributions) and anglePar0 (for the angle distributions).  We then need to decide which statistical distributions best describe the steplengths and turning angles.  The statistical distribution selected then informs how many parameters we need to set.  

As default, [moveHMM]((https://cran.r-project.org/web/packages/moveHMM/index.html) uses the gamma distribution to describe steplengths and the von Mises for turning angles.  We will use the defaults here.  Other available distributions for steplength include: Weibull ("weibull"), exponential ("exp"), and log-normal ("lnorm").  Other available distributions for turning angle are the wrapped-Cauchy ("wrpcauchy"). Please experiment with the other distributions to find the best fitting model.  

Model fitting requires us to specify the number of behavioral states we want to identify and whether a covariate informs the transition from one state to the next.  As a starting point, we will first fit a NULL model where there are two behavioral states, but no covariates influencing behavioral transitions.

## Set Starting Values
The "gamma" distribution requires us to set two (or potential three) parameters describing the steplengths of our animals: mean and standard deviation.  The third potential parameter, called zero mass, is required if we have steplengths that are exactly zero.  This parameter accounts for zero inflation in the gamma distribution, which is a strictly positive distribution and will cause an error if not included.  The "von Mises (vm)" distribution requires us to set two parameters describing the turning angles.  These are the mean turning angle and the angle concentration, which reflects the variance in the turning angle distribution.  It is also possible to specify angleDist = "none" if the angles are not modeled.

Here, we will choose initial values that correspond to commonly observed patterns in 2-state HMMs for animal movement data, with state 1 involving relatively short steps and many turns (small mean steplength and large mean turning angle) and state 2 involving longer steps and fewer turns (large mean steplength and small mean turning angle).

**Note** Selection of starting values can be crucial and heavily impact final results.  To ensure starting values do not overly impact results, some authors will repeat model fitting with a range of starting values. This allows one to test the sensitivity of results to starting value decisions.

```{r Start, message=FALSE, warning=FALSE, echo=TRUE}
# Let's first determine if we have any step lengths of 0.  If yes, we need to include a zero mass parameter.
# The slice_min() command, as specified here, allows us to view the 10 lowest values of the steplength parameter.  It's a convenient function to order by the minimum steplengths.
slice_min(WB.move,
          order_by = step,
          n = 10)
# Values are small, but no zero steps included in the dataset

# Starting Values - Steplengths
# *****************************
# Mean
mu0 <- c(0.1, 1)
# Standard deviation
sigma0 <- c(0.1,1)
# Zero Mass, if required
#zeromass0 <- c(0.1, 0.05)

# Assigning the step distribution starting values
stepPar0 <- c(mu0,
              sigma0)
# Add zeromass0 if required

# Starting values - Turning angles
# ********************************
# Mean turning angle. In radians, pi, or 3.14 represents 180 degrees.
angleMean0 <- c(pi, 0)
# Angle concentration.
kappa0 <- c(1, 1) 
# Assigning the angle distribution starting values
anglePar0 <- c(angleMean0,
               kappa0)
```

## Model Fitting
We will now use the function `fitHMM` to fit our NULL model.  We specify the properly formatted "move" object, define the number of states, input our starting values, and identify our steplength and turning angle distributions.  Since this is our NULL model, we assume that no covariates influence behavioral transitions between states.  We specify the NULL using standard regression formula specification (i.e., ~ 1). 

The model summary provides a detailed numeric output, including the mean steplength from each predicted state and the standard deviation.  We see that state 1 has a much smaller steplength (~ 287m) than state 2 (~ 694m).  For turning angle means, we see that the mean of state 2 is much closer to 0.  This would indicate continued movement in roughly the same direction (i.e., directed movement).  Since we did not test a regression equation, we only have an intercept regression coefficient. 

We are also provided with a matrix of predicted transitions, showing the average probability of transitioning from state 1 to state 2 (~ 3%) and vice versa.  The diagonals (the probability of remaining in each state) of the transition matrix are also very high (~95%), fitting in with what we'd expect behaviorally.  The resulting plots describe the distributions of steplengths and turning angles for our two states.  Paths are colored based on the predicted state for each animal, which is very interesting.

```{r Fitting, message=FALSE, warning=FALSE, echo=TRUE}
# Fit NULL model
WB.null <- fitHMM(data = WB.move, 
                      nbStates = 2, 
                      stepPar0 = stepPar0, 
                      anglePar0 = anglePar0, 
                      stepDist = "gamma",
                      angleDist = "vm",
                      formula = ~ 1)
WB.null
```

## Plotting Results
Now that we have a fitted model, we can plot the results to visualize the state predictions displayed in different colors.

```{r Fitting Plots, message=FALSE, warning=FALSE, echo=TRUE}
# Plot the results of the predictions.  
# Colored states (State 1 is orange; state 2 is blue) provide the predicted state in each trajectory.  
# Plot all animals
# plot(WB.null,
#      ask = F)

# Plot individual animals
plot(WB.null,
     animals = "Kiranto",
     ask = FALSE)
```

## State Assignments & Probabilities
To decode the state processes identified, we will implement the Viterbi algorithm using the function `viterbi()` and compute state probabilities using the function `stateProbs()`. The Viterbi algorithm computes the sequence of most probable states to have generated the observations under the fitted model. State Probabilities computes the probabilities of the underlying Markov chain being in different states at each observation under the fitted model.  Both state assignments provide a predicted state for each location in our dataset, allowing us to look at (for example) the proportion of time spent in each state.  

### Viterbi Algorithm
Results from using the Viterbi algorithm indicate that wildebeest spend about 66% of time in a resident/encamped movement state (state 1).  We can look at these statistics for the population or for each individual and graphically display this information by linking the predicted state information to each position.  These results are often a valuable first step and help a researcher think about other variables (e.g., season, breeding state) that could explain potential changes in behavior.

```{r Viterbi, message=FALSE, warning=FALSE, echo=TRUE}
# Run the algorithm on the fitted model
WB.states <- viterbi(WB.null)

# Look at the state assignments.  The result is just a simple vector of state assignments (class 1 or 2). 
WB.states[1:25]

# What's the proportion of time spent in each state?
prop.table(table(WB.states))

# How does this differ between individuals?
# To answer this question, we need to combine the state assignments with the move object
stateProps <- WB.move %>% 
  # create state column
  mutate(state = WB.states) %>%
  
  # add new column that is the total locations for each animal...used to calculate percentages
  mutate(locs = n(),
         .by = ID) %>% 
  
  # summarize for each animal, and each state, the proportion of locations.  
  # Using reframe, as summarize has been deprecated in latest version of dplyr
  reframe(stateProp = n()/locs,
            sex = unique(sex),
            .by = c(ID, state)) %>% 
  
  # This reduces our data frame from the same initial size, to one with just the unique rows of information.
  distinct() %>% 
  arrange(ID, state)

# Graph results, color by sex to look for any potential patterns.  Just a graph summary.
stateProps %>%
  filter(state == 1) %>% 
  mutate(ID = fct_reorder(ID, 
                          stateProp)) %>% 
  ggplot(aes(y = stateProp,
             x = ID, 
             fill = sex)) +
  geom_col(col = "black",
           position = position_dodge()) +
  coord_flip() +
  labs(y = "Prop. time in State 1 (foraging/encamped)") +
  theme_bw()

# Look at Kiranto
# plot(WB.move[WB.move$ID == "Kiranto",],
#      ask = FALSE)
# Interestingly, Kiranto made some long distance movements, although most of his time was spent in state 1

# How does his movement compare with Paita, for example?
# plot(WB.move[WB.move$ID == "Paita",],
#      ask = FALSE)
# A very different movement pattern, even though the amount of time in state 1 is very similar to Kiranto.
```

### State Probabilities
The `stateProbs()` function allows us to investigate the actual transitional probabilities between each point in the dataset.  The output of the function is a matrix, with probabilities for each state.  Values across rows should sum to 1.0. The package guide states that the state with highest probability according to `stateProbs()` might not be the same as the state in the most probable sequence returned by the `viterbi()` algorithm. This is because the Viterbi algorithm performs “global decoding”, whereas the state probabilities are “local decoding”. For more details, see Zucchini et al. (2016).

The `plotStats()` function will plot the most likely state sequence decoded by the Viterbi algorithm (top panel), as well as both columns of the matrix of state probabilities.

```{r State Probabilities, message=FALSE, warning=FALSE, echo=TRUE}
# Calculate state probabilities
WB.probs <- stateProbs(WB.null)
# head(WB.probs)

# Visualize the state sequences for 1 animal
plotStates(WB.null,
          animals = "Kiranto",
          ask = FALSE)

# We can use the built-in plot functions in moveHMM (see help(plot.moveHMM)) or create our own plots
WB.move %>% 
  mutate(state = as.factor(WB.states)) %>%
  filter(ID == "Kiranto") %>% 
  ggplot(aes(x = x*1000,
             y = y*1000,
             col = state,
             fill = state)) +
  geom_path(alpha = 0.5) +
  geom_point(shape = 21,
             alpha = 0.8,
             col = "black") +
  scale_fill_manual(values = c("orange",
                               "cornflowerblue")) +
  scale_color_manual(values = c("orange",
                                "cornflowerblue")) +
  theme_classic() +
  labs(x = "Easting",
       y = "Northing",
       title = "Kiranto")

```

# Model Comparison & Covariate Testing
Now that we have stepped through the process of fitting a NULL model, we will investigate whether ambient temperature or time of day influences the probability of transitioning between behavioral states. We will also test if a 3-state model has more support than a 2-state model, using AIC to evaluate which model is the best fit to the data.  Various other variables could be included to explain behavioral transition probabilities.  For example, we might include distance to water or dense vegetation, the level of human disturbance, or season of the year.  Variables must be numeric to be included in models and should vary throughout the tracking period (e.g., pregnancy status would be a suitable variable to include, but sex would not).  Similar to other regression-based analyses, covariates could or should be standardized (i.e., centered based on the mean and standard deviation) before fitting the model to improve numerical stability.

## Covariate Model - Temperature
As a first example, we will fit a 2-state model with ambient temperature.  We use the same starting values and parameter distributions specified previously in this script, but will add a formula `~ temp` with temperature as a covariate. 

The resulting analyses indicate that the probability of being in state 1 (i.e., encamped/foraging) is very high when temperatures (degrees C) are low.  As temperature increases, however, we see that the probability of being in state 1 starts to decrease.  By the time we reach 40C, the state probability is about 50%.

```{r Temp Model, message=FALSE, warning=FALSE, echo=TRUE}
# Fit covariate model
WB.temp <- fitHMM(data = WB.move, 
                      nbStates = 2, 
                      stepPar0 = stepPar0, 
                      anglePar0 = anglePar0,
                      stepDist = "gamma",
                      angleDist = "vm",
                      formula = ~ temp)

WB.temp

# Built-in plotting function to evaluate the impacts of a covariate
plotStationary(WB.temp,
               plotCI = TRUE)
```

## Covariate Model - Time of Day
Now let's test a model with time of day. Hour of the day is a challenging variable to model in a regression equation because the 23rd hour is very close to the zero hour.  But, if it is modeled as a regular number, this connection will be lost.  The conversion below using sine and cosine allows us to model the hour of the day in a circular format.  A short description of this conversation can be read [here](https://ianlondon.github.io/posts/encoding-cyclical-features-24-hour-time/).  We are again using the starting parameters included in previous models and the gamma and von Mises distributions. 

```{r Time Model, message=FALSE, warning=FALSE, echo=TRUE}
# Fit covariate model
WB.tod <- fitHMM(data = WB.move,
                      nbStates = 2,
                      stepPar0 = stepPar0,
                      anglePar0 = anglePar0,
                      stepDist = "gamma",
                      angleDist = "vm",
                      formula = ~ cos(2*pi*hour/24) +
                       sin(2*pi*hour/24))

WB.tod
```

## 3-State Model
Now let's expand the number of states we can identify in the tracking data while investigating the influence of the same covariate.

```{r MultiState, message=FALSE, warning=FALSE, echo=TRUE}
# Starting Values - Steplengths
# *****************************
mu0_3 <- c(0.1, 0.5, 3)
sigma0_3 <- c(0.05, 0.5, 1)
# Assign
stepPar0_3 <- c(mu0_3, 
                sigma0_3)

# Starting values - Turning angles
# ********************************
angleMean0_3 <- c(pi, pi, 0)
kappa0_3 <- c(1, 1, 1)
# Assign
anglePar0_3 <- c(angleMean0_3, 
                 kappa0_3)

# Fit model
WB.tod.3state <- fitHMM(data = WB.move, 
                      nbStates = 3, 
                      stepPar0 = stepPar0_3, 
                      anglePar0 = anglePar0_3, 
                      stepDist = "gamma",
                      angleDist = "vm",
                      formula = ~ cos(2*pi*hour/24) +
                       sin(2*pi*hour/24))

WB.tod.3state
```

## Model Comparison
Now we'll use AIC to evaluate which model is best fit to the data.  Results indicate that the 2-state time of day model has the best statistical support, with next to no difference between our NULL model and the model including ambient temperature.  Other models, with more relevant predictors are likely to have greater support, but this at least provides a starting point for how to construct these types of models. 

When we plot the results, we are able to investigate the steplength and turning angle distributions as we did previously.  We can also examine a plot of the trajectory, with colors coinciding with behaviors identified. We can also examine how the state probabilities change in relation to time of day.  Our results generally indicate that wildebeest transition from state 1 (resident/encamped) to state 2 (exploratory) around 18:00 and from state 2 to state 1 around 10:00 (both times are East Africa Time).  
```{r Model Comparison, message=FALSE, warning=FALSE, echo=TRUE}
# Which of these two models is a better fit to the data?
# Results indicate that there is next to no difference between the models
AIC(WB.null,
    WB.temp,
    WB.tod,
    WB.tod.3state)

WB.tod

# Plot the results
# plot(WB.tod,
#      ask = FALSE)

# Plot an individual
plot(WB.tod,
      animals = "Kiranto",
      ask = FALSE)
```

# Further Applications
Similar to activities demonstrated above, we could encode the behavioral states identified to our original dataframe to our best fitting model.  By doing so, we would be able to calculate how much time animals remain in particular behavioral states, compare differences in animal behavior between study areas, or identify areas that are associated with certain behavioral states.  This could be particularly helpful if your goal was to separate the data to create seasonal home range where animals are mostly resident.  

As an example, let's filter the data by state behaviors and plot each behavior separately.  We'll follow the same procedure that we demonstrated above.  The output shows some clear areas where one of the wildebeest (Sawani) spent large periods in a encamped state, but there are quite a few points where these areas over.  This is the kind of approach, however, that might work better for other species.

```{r Applications, message=FALSE, warning=FALSE, echo=TRUE}
# Encode the behaviors using the Viterbi algorithm
WB.tod.states <- viterbi(WB.tod)

# add to the dataset and remove some extra fiels
WB.states <- WB.move %>% 
  mutate(state = as.factor(WB.tod.states)) %>% 
  # Remove some fields to make dataset smaller
  select(-c(step,angle,temp,hour))

# Create plot of Resident behaviors (State 1) for 1 individual
WB.State1 <- WB.states %>% 
  filter(state == 1 & ID == "Sawani") %>% 
  ggplot(aes(x = x*1000,
             y = y*1000,
             col = state,
             fill = state)) +
  #geom_path(alpha = 0.5) +
  geom_point(shape = 21,
             alpha = 0.8,
             col = "black",
             show.legend = FALSE) +
  scale_color_manual(values = "orange") +
  scale_fill_manual(values = "orange") +
  theme_classic() +
  labs(x = "x",
       y = "y",
       title = "Sawani - Resident Only")

# Create plot of exploratory behaviors (State 2) for 1 individual
WB.State2 <- WB.states %>% 
  filter(state == 2 & ID == "Sawani") %>% 
  ggplot(aes(x = x*1000,
             y = y*1000,
             col = state,
             fill = state)) +
  #geom_path(alpha = 0.5) +
  geom_point(shape = 21,
             alpha = 0.8,
             col = "black",
             show.legend = FALSE) +
  scale_color_manual(values = "cornflowerblue") +
  scale_fill_manual(values = "cornflowerblue") +
  theme_classic() +
  labs(x = "x",
       y = "y",
       title = "Sawani - Exploratory Only")

# Use the cowplot package to combine these plots next to each other.
two_plots <- cowplot::plot_grid(WB.State1,
                                WB.State2,
                                ncol = 2,
                                rel_widths = c(1, 1))

# Show the plots
two_plots

# Save the plots
ggsave(plot = two_plots,
       filename = "Output/sawani_residencelocations.tiff",
       units = "in",
       width = 6.5,
       height = 4)
```