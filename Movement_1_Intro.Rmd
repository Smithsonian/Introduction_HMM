---
title: "Introduction to Movement Data & Metrics"
author: "Dr. Wenjing Xu (wenjing.xu@senckenberg.de)"
date: "June 27, 2024"
header-includes:
  - \usepackage{float}
  - \floatplacement{figure}{H}  
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    fig_caption: yes
    theme: yeti
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) # display both code and results 
knitr::opts_chunk$set(fig.pos = 'H')
```

--------------------------------------------------------

# AIM  

The purpose of today's practical is to learn to **1)** understand movement data structure; **2)** visualize movement data; **3)** interpret movement data using basic movement metrics. Today is also your introduction to the data set that will be used for the rest of this movement ecology practical. Note that our focus is on the ecology rather than on understanding all the details of the R script. Please focus on the figures and their interpretation. 

This practical covers four parts: 

  1. Movement data fundamentals
      + what does movement data look like?
      + learn about "the pipe"
      + working with temporal data
  2. Data visualization 
      + working with spatial data
      + plot movement points
      + make a map 
  3. Movement metrics
      + data cleaning 
      + from points to tracks to steps 
      + basic path-level metrics (step length, speed, turning angle)
  4. Space use 
      + Estimate MCP 
      + Calculating MCP area
      + Data visualization
      
![Fig 1. Etosha National Park](etosha-national-park.jpg)

--------------------------------------------------------

# SETUP

This markdown document will guide you through the R script that can be used for tasks and questions you need to complete. Please create an new R script within the folder containing the dataset . While going through the tutorial, please paste and run code presented here into your own script. Answer your **Questions** as comments in your script you created (using the **#** sign). For some **Tasks** you will need to write your own code into your R script. **Make sure you save your R script as you go.**

### Required Packages  

Install the following package & then use the command `library()` to load each package. Each package contains useful functions to manipulate our data and conduct calculations. 

```{r packages, warning=FALSE, message=FALSE, results='hide'}

# if packaged not installed yet, run the line below with the the "#"
# install.packages("tidyverse", "lubridate", "terra", "sf", "amt")

library(tidyverse) #the tidyverse is an collection of R packages designed for data science.
library(lubridate) #this helps us deal with time. It is a part of the tidyverse but not automatically loaded.
library(sf) #"simple features", lets us work with spatial vector data
# library(terra) #methods for spatial data analysis with vector and raster
library(amt) # amt = animal movement tool. It is used to manage and analyze animal movement data. It can be used to calculate home range, track statistics, and prep the data for further analysis such as resource selection function (which you will learn more on day 3)
```

```{r , echo = F, message=F}

library(knitr) 

```

### Set Working Directory 

Please copy your file location (should be something like *C:/.../Movement_1_Intro*) and paste it into *setwd(" ")*. Windows users: Make sure that you reverse all back-slashes to forward-slashes (**/**). 

```{r results='hide'}

setwd(dirname(rstudioapi::getSourceEditorContext()$path))

```

### Load Data 

```{r read data}

data <- readRDS("data/allSpp_intro.rds")

head(data, 50)

```

This dataset was previously published in: 

Abrahms B, Seidel DP, Dougherty E, Hazen EL, Bograd SJ, Wilson AM, McNutt JW, Costa DP, Blake S, Brashares JS, Getz WM (2017) "Suite of simple metrics reveals common movement syndromes across vertebrate taxa. Movement Ecology 5:12.
[doi:10.1186/s40462-017-0104-2](http://dx.doi.org/10.1186/s40462-017-0104-2)

and are publicly available under:

Abrahms B (2017) Data from: Suite of simple metrics reveals common movement syndromes across vertebrate taxa. Movebank Data Repository.
[doi:doi:10.5441/001/1.hm5nk220](http://dx.doi.org/10.5441/001/1.hm5nk220)

This dataset contains GPS data on African mammals that were collared in Etosha National Park in Northern Namibia.

![Fig 2. Etosha National Park](etosha-map.jpeg)

--------------------------------------------------------

# PART 1: MOVEMENT DATA FUNDAMENTALS

Now let's look at the dataset. 

As you probably know by now, there are many ways we can look at our data. Some helpful functions are:  

  + `head()` to look at the first 6 lines of data
  + `dim()` to look at dimensions of data (i.e., how many rows and columns)
  + `str()` to look at each column, the type of data in each column, and the general dimensions of the data frame  
  
```{r look at the dataframe}

head(data, 3)
dim(data)
```

|           **QUESTION 1: ** How many records are there (i.e. number of rows) in the data set? 
<br/><br/>
   

``` {r look at the dataframe 2}
str(data)

```

|           **QUESTION 2: ** What is the data type of the lat variable? What about ID? What about time? 
<br/><br/>
  

Let's put the data into a slightly different format: 
```{r}

data <- as_tibble(data)

str(data)

```
This data format is called 'tibble', a modern reimagination of the data frame. Tibble is particularly useful for large datasets and is the basics for many packages used today. You can learn more about tibbles at <https://tibble.tidyverse.org>. 


### Basic data information
Now we see what movement data generally looks like: location data (X/Y or lat/lon) of an labeled individual, each labeled with a timestamp. In addition to the basic spatial and temporal information, we can also species identity information like animal sex and age, or environmental information like how far a point is from roads or water. But here are some fundamental things to figure out: 

  + How many individuals in total in the data? Are they all of the same species?
  + For how long was the data collected? 
  + What are the start and end dates of the data?
  + At what temporal interval were the GPS points taken? 
  
Let's look at how we can get these information. 

A simple method is to use `unique()` and `length()` functions to know how many species there are in the data. 

```{r unique species}
unique(data$commonName)
length(unique(data$commonName))
```
From the results we know that there are four species: springbok, jackal, zebra, and elephant.

|           **QUESTION 3 **: How many individuals in total do we have data on?
|           *tips: use and modify the code above and answer this question in your R script. *
<br/><br/> 

We can use the 'dplyr' package to get a summary table for the data. 

```{r dplyr data summary}

data %>% 
  group_by(commonName) %>% 
  summarise(n_ind = length(unique(ID)))

```

From the resulted table we can quickly see the number of individuals for each species. 

Similarly: 

```{r dplyr data summary2, message = F}

data %>% 
  group_by(commonName, sex) %>% 
  summarise(n_ind = length(unique(ID)))

```
|           **QUESTION 4**: How many female jackal do we have in the dataset?
<br/><br/> 


### Brief introduction to the pipe 
You might have noticed the `%>%` structure in the codes above. All of the dplyr functions take a data frame (or tibble) as the first argument. Rather than forcing the user to either save intermediate objects or nest functions, dplyr provides the `%>%` operator. `x %>% f(y)` turns into `f(x, y)` so the result from one step is then “piped” into the next step. You can use the pipe to rewrite multiple operations that you can read left-to-right, top-to-bottom (reading the pipe operator as “then”).

Here are some dplyr functions that will be used today to cover basic data manipulation needs:

* Rows:
    + `filter()` chooses rows based on column values.
    + `arrange()` changes the order of the rows.
* Columns:
    + `select()` changes whether or not a column is included.
    + `mutate()` changes the values of columns and creates new columns.
* Groups of rows:
    + `summarise()` collapses a group into a single row.

For example, here is now we can filter only elephant data and get some summary statistics: 

```{r dplyr elephant data summary}

data %>% 
  filter(commonName == "elephant") %>% 
  group_by(ID) %>% 
  summarise(n_point = n())

```

|           **QUESTION 5:** How many location points are there for each elephant individuals?
<br/><br/>


|           **QUESTION 6:** Using the pipe structure, how many female and male location points do we have for jackal?
|           *Tips: first filter data to only jackal, then group them by sex, and finally summarize total point number.*
<br/><br/>


### Working with temporal data

Now let's focus on the temporal inforamtion of the data set. There are two columns that contained temporal information: "date", and "time".  

```{r temporal 1 look at date and time}

head(data$date)
class(data$date)

head(data$time)
class(data$time)

```

As we can see, R currently treat these information as "character". We need to let R know that these are temporal information. The package `lubridate` provided many useful functions for working with temporal data. 

```{r temporal 2 datetime}

data <- data %>% mutate (timestamp = lubridate::ymd_hms(paste(date, time)))

head(data$timestamp)
class(data$timestamp)

```

We first paste the date and time together, then use `ymd_hms()` function from the `lubridate` package to tell R that these characters represent year-month-day-hour-minute-second. Now we noticed the datetime column is recognized as `POSIXct`, a Date-Time Class of R. 

However, notice the "UTC" following each timestamps? It indicates the time zone. Because the data were collected in Namibia, the local time should be UTC+2. 

```{r temporal 3 time zone, warning=F}

data <- data %>% mutate (timestamp = ymd_hms(paste(date, time), tz = 'Africa/Windhoek'))

head(data$timestamp)

```

With a new column in POSIXct class and the correct time zone, we can now extract specific temporal information. `lubridate` provides many easy-to-use functions: 

```{r temporal 4 time basics}

data <- data %>% mutate (year = year(timestamp), 
                         month = month(timestamp),
                         day = day(timestamp),
                         doy = yday(timestamp),  # day of year, or Julian day
                         hour = hour(timestamp))

head(data, 3)

```

We can also do some summary statistics on the temporal information, such as the starting and the ending of the tracking data.

```{r temporal 4 time basics 2}

data %>% 
  filter (commonName == "springbok") %>%
  group_by(ID) %>%
  summarise(start_time = min(timestamp, na.rm = T), 
         end_time = max(timestamp, na.rm = T), 
         track_duration = end_time - start_time)

```

We can see that springbok data did not start at the same time but all ended on Feb 28th, 2010. Hence difference individuals have different tracking duration. 

|           **QUESTION 7:** Slightly modifying the code above, how long was each individual elephant tracked? Is every individual tracked for the same amount of time? 
<br/><br/>


Finally, we can calculate temporal intervals among each locations. 
```{r temporal 4 interval}

data %>% 
  filter (commonName == "springbok") %>%
  group_by(ID) %>%
  summarise(interval = median(diff(timestamp),na.rm = T))

```

|           **QUESTION 8:** What's the median time between locations?
<br/><br/>


### Summary

Now you have learned how to describe basic information of a movement dataset! 

|           **QUESTION 9:** Describe the dataset by filling the blanks below. We have already calculated the stats for most of the blanks. Only the last three blanks might need some tweaks of the previous code provided. You can use this as a reference for the next few days since we will continue to work with this data set: 
<br/><br/>

|           <span style="color: grey;"> This data set contains information on **______** species of African mammals found in Etosha National Park. </span>  
|           <span style="color: grey;"> For each species, we have data on multiple individuals:</span>  

|               <span style="color: grey;">  + Elephants, n = **_________**</span>  
|               <span style="color: grey;">  + Zebras, n = **__________**</span>  
|               <span style="color: grey;">  + Springbok, n = **_________**</span>  
|               <span style="color: grey;">  + Jackals, n = **_________**  </span>  

|           <span style="color: grey;"> GPS points were taken every **______** for all individuals.  </span> 
|           <span style="color: grey;"> The dataset started on **_________** (DD-MM-YY) and ended on **_________** (DD-MM-YY). </span>  

<br/><br/>

--------------------------------------------------------

# PART 2: VISUALIZATION 

For the rest of the practical we will focus on the elephants. Let's first subset our data to just the elephants using the `filter()` from `dplyr`, as shown previously. 

```{r filter to elephants, results='hide'}

elephants <- data %>% filter(commonName == "elephant")

```

### Visualizing movement data

Fundamentally, visualizing movement data is to plot the point locations. 


#### Figure 1: elehpant trajectory

```{r fig 1, fig.height=8}

plot(elephants$lon,elephants$lat, 
     col = as.factor(elephants$ID), 
     pch = 16, 
     ylab ='latitude (degrees)', 
     xlab = 'longitude (degrees)', 
     asp = 1)

```

You can notice that the locations are in decimal degrees (latitude & longitude). 

As we learned from the presentation previously, latitude & longitude  describe the location of points on Earth using a **geographic coordinate system**, or **angular coordinates**. You can see from the image below that the distance between lines of latitude gets smaller at the poles. So while it is useful to map places on earth via (Lon, Lat), it is not so convenient for doing analyses like calculating areas or distances. 

![Fig 2. Geographic coordinate system](longitude-and-latitude-simple.png)
<br/><br/>

Hence, we have **projected coordinate systems**. Basically, it transfers points on a 3-D sphere onto a 2-D plain. In projected coordinate systems, points are characterised by X-Y in meters - which makes calculating distance much easier. Both **geographic coordinate system** and **projected coordinate systems** are called **Coordinate Reference System (CRS)**. *Please check the presentation slides if you want to be refreshed on these concepts.* 

![Fig 3. Projected coordinate system](projected_coordinate_system.png) 
<br/><br/>

It is important to remember that **no CRS is perfect, but some are better than others** (depending your focal area of interest and your analytical goals).

For our study area, Etoshia National Park in Namibia, the greographic coordinate system can be defined in R on a `PROJ.4` notion as `+proj=longlat +datum=WGS84 +no_defs`, which equals to the EPSG code `EPSG:4326`. For projection coordinate system, we choose to use a "equal area projection", defined using a `PROJ.4` notion as `+proj=utm +zone=33 +south +datum=WGS84 +units=m +no_defs +type=crs`, or the EPSG code as `EPSG:32733`. You can find how different notions of different CRS from [this website](https://epsg.io/). 

With this context, we can tell R that our elephant data is a spatial data defined by a particular CRS. We can also transform the data from one CRS to another. 

```{r elephants sp}

class(elephants)

# turn elephant dataframe to spatial dataframe with a defined CRS
elephants.sp.wgs <- st_as_sf(elephants, coords = c("lon", "lat"), crs = st_crs(4326)) # only the EPSG code is needed here
head(elephants.sp.wgs,3)
# transform to projected coordinate system
elephants.sp.utm <- elephants.sp.wgs %>% st_transform(crs = st_crs(32733))
head(elephants.sp.utm, 3)
```
The way to plot spatial objects is similar to the method used to plot the data frame (notice the axis units have changed):

#### Figure 2: elehpant trajectory - UTM

```{r fig 2, fig.height=8}

plot(st_geometry(elephants.sp.utm), 
     axes = TRUE,
     col = as.factor(elephants$ID), 
     ylab ='Y (meters)', 
     xlab = 'X (meters)', 
     pch = 16, asp = 1)

```

|           **QUESTION 10:** What is the EPSG code for "WGS 84 Pseudo-Mercator" coordinate reference system? Transform the elephant data to this coordinate system and plot the data with x-y axis. How it is different from figure 2?
|           *tips: use the website provided earlier to search for the CRS information.*
<br/><br/>


### Making a map for all individuals

Let's make some maps of the elephant data to make some qualitative observations. This will be useful to generate questions and make observations that we can quantify later on. 

First, we read in the shapefiles of the Etosha National Park boundary, the artificial water holes within the park, and all tourist traveled roads. 

```{r read spatial data, results='hide'}

# read in Etosha boundary
etosha.boundary <- read_sf("data", "enp_fence_poly") 

# read in water holes
water.holes <- read_sf("data", "water_holes")

# read in ALL tourist roads
roads <- read_sf("data", "all_tourist_travelled_roads")

```

|           **QUESTION 11:** Please check the coordinate reference system of Etosha boundary. What CRS do they use? Are their CRS the same?  
<br/><br/>

When making a map, we should start with plotting the boundary of the park because this is the largest shape and determines the spatial extent of the map. The order of the plotting determines the layer order. `add = T` tells R to plot the object on top of the previous object, rather than creating a new plot. **Make sure all your objects are in the same CRS so that they can be displayed correctly.**

#### Figure 3: base R map

```{r map 1}

plot(etosha.boundary$geometry)
plot(water.holes$geometry, col = "blue", pch = 16, add = T)
plot(roads$geometry, col ='brown', add = T)
plot(elephants.sp.utm$geometry, col = as.factor(elephants$ID), pch = 16, cex = 0.5, add = T)

``` 

Alternatively, `ggplot()` provides a more flexible way to create plots:

#### Figure 4: ggplot map

```{r map ggplot}

p4 <- ggplot() + 
  geom_sf(data = etosha.boundary, fill = "white") + # layer 1: boundary
  geom_sf(data = roads, colour = "darkgrey") + # layer 2, roads
  geom_sf(data = water.holes, colour = "blue") + # layer 3, water holes
  geom_sf(data = elephants.sp.utm, aes(color = elephants.sp.utm$ID), size = 0.5) +
  theme_minimal() # a minimal map theme for aesthetics 
p4

```

|           **QUESTION 12:** Record 4 things that you notice about the animals' space use in this map or questions that come to mind when you see the data. This is helpful to form hypotheses.
*There is no correct answer here, simply your questions & observations.*
<br/><br/>
 
### Saving a map

If you would like to save nice versions of your figures you can use the following code:  

|           `png(file = "Name_of_Figure.png", units = "in", width = 12, height = 8, res = 300)` 
|           `[CODE FOR CREATING THE MAP]`
|           `dev.off()`

You can adjust the width & height as needed. If you set your working directory, then the figures will be saved there. Otherwise specify a full file path. Your plotting code goes between the `png()` and `dev.off()`. `dev.off()` tells R that the plotting code is done and it can save the plot.  


For example, previouly we already created the map `p4` using ggplot, so we can save the plot by:

```{r save figure 1, fig.show='hide', results='hide', eval = FALSE}

png("map_elephants_1.png", units = "in", width = 12, height = 8, res = 300)

p4

dev.off()
```

It is the same as: 
```{r save figure 2, fig.show='hide', results='hide', eval = FALSE}

png("map_elephants_2.png", units = "in", width = 12, height = 8, res = 300)

ggplot() + 
  geom_sf(data = etosha.boundary, fill = "white") + 
    geom_sf(data = roads, colour = "darkgrey") + 
  geom_sf(data = water.holes, colour = "blue") + 
  geom_sf(data = elephants.sp.utm, aes(color = elephants.sp.utm$ID), size = 0.5) +
  theme_minimal() 

dev.off()
```


### Zooming in to one individual

If you are more interested in one particular individual, we can make a map to zoom in on it to look at the detail. Remember that the first spatial object determines the extent of the map. Hence, we can use the specific elephant trajectory to define the extent. `st_bbox` is the function to extract spatial extent for a given object. 

#### Figure 5: mapping one individual trajectory 

```{r individual elephant plot 1}

one.elephant <- elephants.sp.utm %>% filter(ID == "elephant.5") 

p5 <-  ggplot() +
  geom_sf(data = etosha.boundary, fill = "white") + 
  geom_sf(data = roads, colour = "darkgrey") +
  geom_sf(data = water.holes, colour = "blue") +
  geom_sf(data = one.elephant, colour = "orange") + # ndividual elephant data
  # below code set the plot extent. st_bbox() extracts the spatial extent of the given object. 
  xlim(st_bbox(one.elephant)$xmin, st_bbox(one.elephant)$xmax) + 
  ylim(st_bbox(one.elephant)$ymin, st_bbox(one.elephant)$ymax) +
  theme_minimal() # a minimal map theme for aesthetics 
p5

```

|           **QUESTION 13:** what is the spatial extent of elephant 5? What about elephant 8?
<br/><br/>

### More customization of your map 

`ggplot` provided many ways to customize the map. On top of this basic figure, we can also customize many properties of each mapped objects, such as color, shape, and size.

For example, we can color the points by month. To do that, we need to tell R to treat month as factor rather than a numbers. 

#### Figure 6: mapping one individual trajectory by month

```{r individual elephant plot 2}

one.elephant <- one.elephant %>% 
  mutate (month = factor(month, levels = c("9", "10", "11", "12", "1", "2"))) %>% # turn month into factor and make sure the levels follow actual month orders. Because the data goes from Sept. 2009 to February 2010, we need to order the months 9, 10, 11, 12, 1, 2 to reflect how the data was collected.
  filter(!is.na(month)) # we only want to plot points with month information

p6 <-  ggplot() +
  geom_sf(data = etosha.boundary, fill = "white") + # layer 1: boundary
  geom_sf(data = roads, colour = "darkgrey") + # layer 2, roads
  geom_sf(data = water.holes, colour = "blue") + # layer 3, water holes
  geom_sf(data = one.elephant, aes(colour = month)) + # layer 4, individual elephant data, color by month
  # below code set the plot extent. st_bbox() extracts the spatial extent of the given object. 
  xlim(st_bbox(one.elephant)$xmin, st_bbox(one.elephant)$xmax) + 
  ylim(st_bbox(one.elephant)$ymin, st_bbox(one.elephant)$ymax) +
  theme_minimal() # a minimal map theme for aesthetics 
p6

```

We can provide customized color palette for `ggplot` to use. We can also change the position of the legend, or the theme of the whole plot. 

For example: 

#### Figure 7: mapping one individual trajectory by month with customized tyles

```{r individual elephant plot 4}

palette1 <- c("cornflowerblue", "purple", "black", "chartreuse4", "red", "darkgoldenrod1")

p7 <-  ggplot() +
  geom_sf(data = etosha.boundary, fill = "white", linetype = "longdash", linewidth = 2) + # change the type of lines to differentiate from roads
  geom_sf(data = roads, colour = "darkgrey", linewidth = 1.5) + 
  geom_sf(data = water.holes, colour = "blue", size = 3, shape = 15) + # Here we use shape to change the shape of water hole so it can be better differentiated from movement points.
  geom_sf(data = one.elephant, aes(colour = month)) + 
  scale_color_manual(values = palette1) + 
  xlim(st_bbox(one.elephant)$xmin, st_bbox(one.elephant)$xmax) + 
  ylim(st_bbox(one.elephant)$ymin, st_bbox(one.elephant)$ymax) +
  theme_linedraw () + # a "linedraw" map theme for aesthetics 
  theme(legend.position = "bottom") # move the legend to the bottom of the map
p7

```

|           **TASK 1:** make a map that contains both elephant 3 and elephant 6. Color the points by year. Play around the different ways you can stylize the map and save your favorite map as a png figure on your computer.
*tips: you can use `ID %in% c("elephant.3", "elephant.6")` to filter the two elephants from the spatial elephant dataset* 
<br/><br/>


--------------------------------------------------------

# PART 3: MOVEMENT METRICS

Previously we have been working with movement data as its raw form: points. To understand further on how the animals are moving, we can look at the data as movement tracks and look at the relationships between consecutive points. In other word, we want to learn more about how the animal moves from one location to the another. 

### Data cleaning

To turn points into tracks, we first need to do some data cleaning: 

  1. check if any coordinates are missing. If so, remove the incomplete relocation;
  2. make sure a time stamp column exist (previously we have created it in *PART 1*);
  3. check for and remove any duplicated time stamps.


```{r data clean}
# check is all observations are complete 
all(complete.cases(elephants)) 
``` 

We see that not all cases are complete. Let's remove these incomplete cases.  

```{r clean data}
# we focus on the three most important columns that represent time and locations. filter the rows with NAs in these columns
elephants <- elephants %>% filter(!is.na(timestamp),
                                  !is.na(lon), !is.na(lat)) 

# check again
all(complete.cases(elephants)) 

# all good now.
```

Now check whether any time stamps are duplicated for each individual:
```{r check duplication}
elephants %>% group_by(ID) %>% summarise(any(duplicated(timestamp)))
```

We have no duplicated timestamp within each individual. Great! 

### Track creation 

```{r create track}
elephants.trk <- make_track(elephants, 
                            # tell the function which column contains the coordinates
                            .x = lon, .y = lat, 
                            # tell the function which CRS the coordinates are based on. 
                            crs = 4326, 
                            .t = timestamp,
                            # any additional information you want to attach to the track
                            # such as animal ID and month
                            id = ID, month = month) 

class(elephants.trk)
```

Now we have a movement track. But at the same time it is still a tibble. Hence, the pipe operations from `dyplr` still work for tracks created by `amt`.

### Working with tracks

```{r track manipulation}
# transform CRS to WGS 84 / UTM zone 33S, whose EPSG code is 32733. 
elephants.trk.UTM <- transform_coords(elephants.trk, 32733)

# filter track to one individual
one.elephant.trk <- elephants.trk.UTM %>% filter(id == "elephant.5")
```

As mentioned before, projected coordinate system is better for distance calculation. Hence, the rest of the analysis will be conducted within the UTM system. 

### Step statistics

Starting with one individual, we can calculate animal step lengths (i.e. distance between the neighboring locations).

```{r step length}

one.elephant.trk  <- one.elephant.trk %>% 
  # use `mutate` to create a new column to store step length
  mutate(sl_ = step_lengths(one.elephant.trk))

```

Let's look at a summary of `sl_`:
```{r summary sl}

summary(one.elephant.trk$sl_)

```

|           **QUESTION 14:** There is a NA in the step length calculation result, but it is as expected. Why? 
<br/><br/>


We notice that the range of step lengths is fairly large - from 0 to almost 3.5 km. We can visualize the distribution using a histogram: 

```{r sl visualization, warning=F}

ggplot(one.elephant.trk, aes(x = sl_)) + 
  geom_histogram(bins = 80) +
  theme_minimal()

```

We can see that the step lengths are not normally distributed. Rather, most step lengths were small. 

Following similar process, `amt` allows us to calculate other basic movement metrics such as speed, relative turning angle, and absolute turning angle: 

```{r basic metrics}

one.elephant.trk  <- one.elephant.trk %>% 
  # calculate speed in m/s
  mutate(speed = speed(one.elephant.trk), 
  # relative turning angle
  rel_ta = direction_rel(one.elephant.trk), 
  # absolute turning angle
  abs_ta = direction_abs(one.elephant.trk)) 

head(one.elephant.trk)
```

Now we have a track data frame with most common movement metrics calculated. 

Alternatively, `amt` also provided us a quick way to calculate common step statistics at once. Let's use the track of a different elephant as an example: 

```{r step}
# first we filter the data to the individual of interest
another.elephant.trk <- elephants.trk.UTM %>% filter(id == "elephant.6")

# because we have cleaned for the full elephant data set
# we know the data for elephant 6 is cleaned. 
# hence we can directly transform the data frame into "steps"
another.elephant.steps <- steps(another.elephant.trk)

head(another.elephant.steps)

```

As demonstrated, using `steps()`, we can quickly calculate step statstics for a track, in which `x1_` and `y1_` are the coordinates of the first location, and `x2_` and `y2_` are the coordinate of the second location. In the new tibble, we see the step length `sl_`, turning angle `ta_`, and step duration `dt_`. 


|           **Task 2:** Please make two histograms of the step length of *elephant 8* for *September* and *January*. Is the animal moving at similar step lengths in these two months?
*tips: you need to filter the data set using two different columns, one is "ID", the other is "month". *
<br/><br/>

### Working with several individuals concurrently 

Up to now we have only considered situations with one animal. However, we have in total four elephants tracked and we often want movement characteristics calculated for several animals together. `amt` does not provide a infrastructure for dealing with several animal. However, list-columns from the `tidyverse` can be used to manage many animals. 

Because a track is just a tibble all tidyverse verbs can be used. The general strategy consists of three steps:

**1.** Nest a track by one or more columns (such as by ID). This retains the unique values of the grouping variable(s) and creates a new list-column with tracks (basically tibble nested in a tibble).

```{r nest}

elephants.trk.nested <- elephants.trk %>% nest(data = -"id")

elephants.trk.nested
  
```

Individual tracks are now stored is now stored in a new column called "data". 

**2.** Now we can perform operations on the grouped data by using `mutate` and `map`. *`map` applies a function to each elephant of a vector/list.* 

```{r turn to step}

elephants.nested <- elephants.trk.nested %>% mutate (steps = map(data, function(x) {x %>% steps()} )) 

elephants.nested

# let's look at one element in the column "steps"
elephants.nested$steps[1]

```


**3.** `select()` the relevant columns and `unnest()` to turn the data frame back to a data frame. 

Because we are interested in making a steps data frame containing all individuals, we select column "id" and "steps" and unnest them into a new data frame. 

```{r unnest}

elephants.steps <- elephants.nested %>% 
  select (id, steps) %>% #select the two columns of interest
  unnest(cols = steps) #unnest the steps column

head(elephants.steps)
```
Now all individual steps with movement metrics calculated are in one big data frame. In other words, all step data frames are bind into one.

We can now more easily compare movement metrics of different individuals. As an example, we can plot the step-length distributions of all individuals concurrently now: 

```{r all individual sl distribution}

elephants.steps %>% ggplot (aes(x = sl_, fill = factor(id))) +
  geom_density(alpha = 0.3) + #alpha determines transparency 
  theme_minimal()

```

|           **QUESTION 15:** Do these individuals exhibit similar step lengths? 
<br/><br/>


### Visualizing angular distributions 

One of the step metrics `amt` calculated is relative angles (turning angles). We can of course still visualize the angular distribution using the same method as for step lengths: 

```{r all individual angle distribution, warning=F}

elephants.steps %>% ggplot (aes(x = ta_, fill = factor(id))) +
  geom_density(alpha = 0.3) + #alpha determines transparency 
  theme_minimal()

```

Notice the angles were calculated as radians rather than degrees. For easier interpretation, we can turn the radian to degree. 

```{r radian-degree}
elephants.steps <- elephants.steps %>% mutate(ta_degree = ta_ * 180/pi)

```

We can also plot the turn angle density distribution on a circle to better represent the "angular" nature. 

```{r circlur plotting}

elephants.steps %>%
  filter(!is.na(ta_degree)) %>% 
  ggplot(aes(x = ta_degree, fill = id)) +
  geom_density(alpha = 0.4) +
  coord_polar() +
  theme_minimal()

```

|           **QUESTION 16:** Do these individuals exhibit similar turning angle distributions? 
<br/><br/>


--------------------------------------------------------

# PART 4: HOME RANGE

Animal movement data can also tell us information about their space use. Even though 6 months of data cannot tell us the full picture of animals' home range across all seasons, we can still use the home range methods to explore their space use within the 6-month time frame. As discussed in the lecture, there are many ways to calculate home range. Here we focus on using *MCP (Minimum Convex Polygon).*

### Calculating MCP for one individual

`amt` provides an easy way to calculate animal home ranges from a track through function `hr_mcp()`. Note that argument `levels` defines the isopleth levels used for calculating home ranges.

```{r mcp for one elephant}

# previously we have created the track for elephant 5
head(one.elephant.trk, 3)

# estimate mcp at the level of 95%
one.elephant.mcp <- hr_mcp(one.elephant.trk, levels = 0.95)

plot(one.elephant.mcp)
```

The plot showed both the movement points and the resulted MCP range. 

We can also visualize it's location relative to the whole park.

#### Figure 8: elephant 5 MCP relative to the entire park  

```{r plot_with_park_boundary}

# first double check that data are in the save CRS:
st_crs(etosha.boundary) == st_crs(one.elephant.mcp$mcp)

p8 <-  ggplot() +
  geom_sf(data = etosha.boundary, fill = "white", linetype = "longdash", linewidth = 1) + 
  geom_sf(data = one.elephant.mcp$mcp, color = "orange") +
  geom_point(aes(x = one.elephant.mcp$data$x_, y = one.elephant.mcp$data$y_), color = "orange", alpha = 0.3) +
  theme_minimal() 
p8
```

We can see from the map that elephant 5 mostly used the center of the park.

### Calculating MCP area for one individual

The area of the resulted MCP can be easily calculated as below: 
```{r mcp area}
hr_area(one.elephant.mcp)
```
### MCP of multiple levels for one individual

Sometimes we want to know where is the core area that animals used. In this case, we can adjust the `levels` arguments to a smaller number. 

```{r multiple levels mcp}
one.elephant.mcp.2 <- hr_mcp(one.elephant.trk, levels = c(1, 0.9, 0.5))

one.elephant.mcp.2$mcp
```

#### Figure 9: elephant 5 mcp with three levels

```{r plot hrs}
p9 <-  ggplot() +
  geom_sf(data = one.elephant.mcp.2$mcp, aes(color = factor(level)), fill = NA, alpha = 0.4, linewidth = 0.8) +
  geom_point(aes(x = one.elephant.mcp.2$data$x_, y = one.elephant.mcp$data$y_), color = "orange", alpha = 0.1, size = 0.3) +
  theme_minimal()
p9

```

We can see that 100% MCP is the largest, but very close to the 90% MCP. In contrast, 50% MCP is much smaller. 

Theoretically it is good to exclude points that are outliers, i.e. not typical of the individual's movement pattern or one-time forays into different areas. Yet as you can see from these plots, the MCP method is not so smart at reducing the home range to just the 'core' area. It essentially picked the points in the geographic center of the points. This has no ecological reasoning behind it, especially when the animal uses space heterogeneously. This is why there are other methods that try to add more information to make a more informed decision. 

|           **TASK 3**: Using code provided above to calculate areas of 50%, 75%, and 95% MCP range size for elephant 8. 
<br/><br/>

### MCP for multiple individual

Calculting MCP for all individuals in `amt` follows the same logic as how we calculate movement metrics for multiple individuals, except for step 3 because we are dealing with list of `sf` objects and we cannot simply unnest sf objects into a dataframe. 

```{r mcp_all_ind, warning=FALSE}

# step 1: nest the track by id

elephants.nested <- elephants.trk %>% nest(data = -"id")

# step 2: calculate mcp 

elephants.nested <- elephants.nested %>% mutate(mcp = map(data, function(x) {
    mcp = hr_mcp(x, levels = 0.95)
    return(mcp$mcp)
    }
  ))

# step 3: combine mcp of multiple individuals to one sf object

elephants.mcp <- bind_rows(elephants.nested$mcp) %>% mutate (id = elephants.nested$id)

elephants.mcp

```
|           **QUESTION 17:** which elephant has the largest 90% MCP?
<br/><br/>



We can also make a plot to compare HR sizes across all individuals more directly:

```{r mcp area bar}

elephants.mcp %>% ggplot() +
  # turn area from m^2 to km^2 for easier interpretation
  geom_bar(aes( x = id, y = as.numeric(area)/1000000), 
           stat = "identity") +
  theme_minimal()

```


|           **QUESTION 18:** What do you think could cause differences in space use?
<br/><br/>


### Home ranges in the park

Now we can easily plot the MCP for all individuals relative to the park: 

#### Figure 10: all elephant 95% mcp in the park

```{r all elephant mcp}
p10 <-  ggplot() +
  geom_sf(data = etosha.boundary, fill = "white", linetype = "longdash", linewidth = 1) + 
  geom_sf(data = elephants.mcp, aes(color = id), fill = NA, alpha = 0.4, linewidth = 0.8) +
  theme_minimal()
p10

```

|           **QUESTION 19:**  Describe what you see in the map. How would this be helpful for conservation planning?
<br/><br/>


### Save the HR results in a data frame.  

Sometimes to report the result you need to export the data as a data frame. `sf` objects can be easily turn into a data frame as below:

```{r same results in a data frame}

elephants.mcp.df <- st_drop_geometry(elephants.mcp)

```

Finally, you can use `write_csv()` to save your data frame as a csv file on your computer. 
<br/><br/>
<br/><br/>
<br/><br/>


------------------------------------
(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ Great job! You made it to the end.

